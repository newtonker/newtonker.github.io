# Android性能优化总结（一）

## 1 什么是性能
![](http://oq54hiwcu.bkt.clouddn.com/2018-09-15-%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20-1-.jpg)
Android性能大致可以概括为快、稳、省、小四个方面。在开发过程中，我们可以从这四个方面分析，判断App还有优化的空间。接下来我们就从上述四个方面来分析，看下应该如何优化我们的App。


## 2 优化方向
### 2.1 布局优化
与UI相关的首先就是布局的优化，比如我们需要开发一个比较复杂的界面，优化布局思路的不同，可能导致这个界面上嵌套的层级过多。

Android的官方文档中介绍到：屏幕上的某个像素点，在同一帧的时间里被绘制了多次。在多层级的UI结构里，如果看不见的UI也在做绘制的操作，这就会导致某些像素区域被绘制了多次。这样浪费了大量的CPU和GPU资源。

![](http://oq54hiwcu.bkt.clouddn.com/2018-09-15-overdraw_hidden_view.png)

在待调试的手机中：开发者选项 -> 调试GPU过度绘制 -> 显示过度绘制区域。这样设置后便可查看GPU的过度绘制问题。如下图所示：蓝色，淡绿，淡红，深红代表了4种不同程度的Overdraw情况，我们的目标就是尽量减少红色Overdraw，看到更多的蓝色区域。
![](http://oq54hiwcu.bkt.clouddn.com/2018-09-15-overdraw_options_view.png)

于是，我们可以总结一下几条布局心得：

1. 如果父控件有颜色，同时也是目标颜色，那就不必在控件中增加背景颜色；
2. 如果每个控件的颜色不一样，而且可以完全覆盖父控件，那就不需要在父控件中设置背景颜色；
3. 尽量减少不必要的嵌套。
4. 能用LinearLayout和FrameLayout的场景下，尽量少用RelativeLayout，因为RelativeLayout控件的onMeasure方法中会对子View做两次测量，执行时间更久。这是因为RelativeLayout是基于相对位置的，而且子View会在横向和纵向两个方向上分布，因此需要在横向和纵向分别进行一次measure过程。

此外，针对嵌套布局，Google也提出了一些方案，比如：include，merge和ViewStub三兄弟。

include可以提高布局的复用性，merge的布局取决于父控件是哪种布局方式，使用merge的作用，相当于减少了自身的一层布局。所以，一般而言include和merge是一起使用的。

ViewStub的主要作用是按需加载，它只有在使用到的时候才会加载到内存。

所以，我们又可以总结两条性能优化的心得：

1. 使用include和merge增加复用性，减少层级；
2. ViewStub按需加载，更加轻便；

此外，针对嵌套问题，Google还推出了ConstraintLayout，它使用约束的方式来指定各个控件的位置和关系，在复杂布局中，它可以有效的解决布局嵌套过多的问题。

所以，我们总结如下：

1. 复杂的界面可以选择ConstraintLayout，有效减少层级；

### 2.2 绘制优化
当我们把布局优化了，但是和布局息息相关的还有绘制。其实，随着手机硬件的逐步提升，布局优化对于性能的提升不算大，但确实我们最容易下手的。平时我们使用APP的过程中感觉到卡顿的主要原因是渲染性能，因为越来越复杂的界面交互中，可能增加了动画，图片等。我们再创造出越来越炫酷的交互界面，恰恰是卡顿可能发生的原因。

这其实是Android的渲染机制造成的，Android每16ms会发出VSYNC信号，触发对UI进行渲染，但未必渲染成功，如果渲染失败，只能等到下一帧在重新渲染。在视觉表现上就是，要么卡了一会，要么跳帧了。

View的绘制频率保证60fps是最佳的，这就要求每帧的绘制时间不超过16ms，这就要求尽量降低onDraw方法中的复杂度。正常情况下，每隔16ms，draw()一帧，很完美。

![](http://oq54hiwcu.bkt.clouddn.com/2018-09-15-draw_per_16ms.png)

但是，当某个耗时操作会费的时间是24ms时，系统在得到VSYNC信号后就无法正常渲染，这样就会出现丢帧的现象。那么用户在32ms的时间内看到的是同一帧画面。

![](http://oq54hiwcu.bkt.clouddn.com/2018-09-15-vsync_over_draw.png)

所以我们的解决方案就是要尽量减少onDraw()的负担。

onDraw方法中不要做耗时的任务，也不做过多的循环操作，特别是嵌套循环，虽然每次循环耗时很小，但是大量的循环会占用CPU的时间片，从而造成View的绘制过程不流畅。

除了循环之外，onDraw()中不要创建新的局部对象，因为onDraw()方法一般都会频繁大量调用，就意味着会产生大量的零时对象，不仅占用过的内存，而且会导致系统更加频繁的GC，大大降低程序的执行速度和效率。

所以，我们总结如下：

1. onDraw()中尽量不要创建新的局部对象；
2. onDraw()中不要做耗时的任务；

其实，从渲染优化里，我们又引出了另一种优化，即内存优化。

### 2.3 内存优化
内存泄漏一般指的是程序中那些不再使用的对象无法被GC回收。当存在内存泄漏时，内存的占用会越来越多，GC很容易被触发，GC会越来越频繁。GC触发时，所有的线程都是暂停状态，需要处理的对象越多耗时越长，这样便很容易造成卡顿。

![](http://oq54hiwcu.bkt.clouddn.com/2018-09-16-android_perf_memory_leak.png)

出现内存的场景大致可以分为以下三大类：

1. 单例/静态变量造成的内存泄漏；
2. 匿名内部类/非静态内部类；
3. 资源未关闭造成的内存泄漏；

#### 单例/静态内部类造成的内存泄漏
当单例持有Activity的context时，很容易造成内存泄漏，因为当Activity要销毁时，单例仍然持有Activity的引用，所以无法GC回收，造成内存泄漏。推荐的做法是单例持有Application的Context。

```java
public class SingleInstance {

    private Context mContext;
    private static volatile SingleInstance mInstance;

    private SingleInstance(Context context){
        // 注意：这里容易造成内存泄漏
        this.mContext = context;
        // 推荐的做法如下：
        // this.mContext = context.getApplicationContext();
    }

    public static SingleInstance newInstance(Context context){
        if(mInstance == null){
        	  synchronized(SingleInstance.class) {
        	      if(mInstance == null) {
                    mInstance = new SingleInstance(context);
                }
            }
        }
        return sInstance;
    }
}
```

#### 匿名内部类/非静态内部类
非静态内部类会持有其外部类的引用，当非静态内部类的生命周期比静态内部类长时，很容易造成内存泄漏。

```java
public class TestActivity extends Activity {

    private Handler mHandler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            // do something
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
		 //...
		 mHandler.sendEmptyMessageDelayed(0, 10_000);
    }
```
上面的例子中，Handler发出了一个10s延时的任务。这种延时时间过长的场景，很容易造成内部类的生命周期大于外部类，造成内存泄漏。推荐的一种做法是：

```java
public class TestActivity extends Activity {
    private MyHandler myHandler = new MyHandler(TestActivity.this);

    private static class MyHandler extends Handler {

        WeakReference<TestActivity> weakReference;

        MyHandler(TestActivity testActivity) {
            this.weakReference = new WeakReference<TestActivity>(testActivity);
        }

        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            TestActivity activity = weakReference.get();
            if(null != activity) {
                // do something
            }
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // ...
        myHandler.sendEmptyMessageDelayed(0, 10_000);
    }
    
    @Override
    protected void onDestroy() {
        super.onDestroy();
        //最后清空消息
        myHandler.removeCallbacksAndMessages(null);
    }
```

#### 资源未关闭造成的内存泄漏
- 网络、文件流未关闭；
- 注册了广播，却未注销；
- Service启动后未关闭；
- EventBus等观察者框架忘记解除注册；

此外，我们还可以借助工具来辅助我们查找内存泄漏：

- leakcanary查找内存泄漏；
- MemoryMonitor进行内存监控；
- AndroidLint提高和改善代码质量；

所以，我们总结如下：
1. 解决常见场景下的内存泄漏，同时注意代码规范。

### 2.4 启动速度优化
提升App的启动性能，可以提高用户体验。Google官方文档《Launch-Time Performance》对应用启动方式的概述如下：

1. 冷启动：指的是应用程序从头开始：系统的进程没有，直到此开始，创建了应用程序的进程。 在应用程序自设备启动以来第一次启动或系统杀死应用程序等情况下会发生冷启动。 这种类型的启动在最小化启动时间方面是最大的挑战，因为系统和应用程序比其他启动状态具有更多的工作。

2. 热启动：与冷启动相比，热启动应用程序要简单得多，开销更低。在热启动，系统会把你活动放到前台，如果所有应用程序的活动仍驻留在内存中，那么应用程序可以避免重复对象初始化，UI的布局和渲染。
热启动显示与冷启动场景相同的屏幕行为：系统进程显示空白屏幕，直到应用程序完成呈现活动。

3. 温启动：用户退出您的应用，但随后重新启动。该过程可能已继续运行，但应用程序必须通过调用onCreate()从头开始重新创建活动。系统从内存中驱逐您的应用程序，然后用户重新启动它。进程和Activity需要重新启动，但任务可以从保存的实例状态包传递到onCreate()中。

这里是慢的定义：

- 冷启动需要5秒或更长时间。
- 温启动需要2秒或更长时间。
- 热启动需要1.5秒或更长时间。

无论何种启动，我们的优化点都是：Application、Activity创建以及回调等过程。谷歌官方给的建议是：

1. 利用提前展示出来的Window，快速展示出来一个界面，给用户快速反馈的体验；
2. 避免在启动时做密集沉重的初始化（Heavy app initialization）；
3. 避免I/O操作、反序列化、网络操作、布局嵌套等。

### 2.5 包体优化
对于产品来讲，包体越小，则用户的转化率可能会越高。对于包体的优化，我们需要从代码和资源两个方面去优化。常用的做法有以下几种：

1. 开启资源压缩，自动删除无用的资源；
2. 能用代码实现的，尽量不要用切图，如果需要用切图的地方，在不影响视觉效果的前提下，尽量减少切图的大小；
3. 插件化。非必须的功能模块可以放到服务端，按需下载。

gradle中删除无用资源的配置如下：

```java
android {
    ...
    buildTypes {
        release {
            shrinkResources true
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android.txt'),
                    'proguard-rules.pro'
        }
    }
```

### 2.6 耗电优化
其实大多数开发者对电量优化的重视程度极低，但我们不能忽视其他的优化，电量优化其实还是必要的，例如爱奇艺、优酷等等的视频播放器以及音乐播放器。众所周知，音乐和视频其实是耗电量最大的。如果用户一旦发现我们的应用非常耗电，不好意思，他们大多会选择卸载来解决此类问题。为此，我们需要进行优化。

谷歌推荐使用JobScheduler，来调整任务优先级等策略来达到降低损耗的目的。JobScheduler可以避免频繁的唤醒硬件模块，造成不必要的电量消耗。避免在不合适的时间(例如低电量情况下、弱网络或者移动网络情况下的)执行过多的任务消耗电量。

此外，对于电量优化，我在此提一些建议：

- 需要进行网络请求时，我们需先判断网络当前的状态。
- 在多网络请求的情况下，最好进行批量处理，尽量避免频繁的间隔网络请求。
- 在同时有wifi和移动数据的情况下，我们应该直接屏幕移动数据的网络请求，只有当wifi断开时在调用，因为，wifi请求的耗电量远比移动数据的耗电量低的低。
- 后台任务要尽可能少的唤醒CPU。（比方说，锁屏时，QQ的消息提示行就是唤醒了CPU。但是它的提示只有在你打开锁屏或者进行充电时才会进行提示。）


### 2.7 其他优化
- 位图bitmap优化
- 响应速度优化；
- 线程优化；

## 参考资料
1. [Android性能优化典范 - 第1季](http://hukai.me/android-performance-patterns/)
2. [Android 性能优化最佳实践](https://juejin.im/post/5b50b017f265da0f7b2f649c?utm_source=gold_browser_extension)
3. [App Startup Time](https://developer.android.com/topic/performance/vitals/launch-time)
4. [Android性能优化之电量篇](http://hukai.me/android-performance-battery/)















- 当数据量不大时，用ArrayMap替换HashMap，当key为int时，采用SparseArray；
- 倒计时方案的一种优化；
- drawable的一种简单实现；


## 卡顿问题

### 是否由UI引起；
- 过度绘制检测；
- 帧率检测；
- 层级检测；


### 是否由内存泄漏引起；
Android自带的Monitor检测；
- 需要分析的场景，是否有内存逐渐变大的趋势；
- 若有，则手动触发gc，然后再次操作需要分析的场景，dump下来分析；
- 内存分析，观察哪些对象占比很高，再查看其引用情况；


### 是否是方法耗时引起；
方法耗时分析工具基本就这么几个：systrace, viewTrace，或者通过打印时间戳；
